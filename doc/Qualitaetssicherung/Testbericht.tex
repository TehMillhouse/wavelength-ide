\documentclass[parskip=full,11pt,openany]{scrreprt}

\usepackage[sfdefault,light]{roboto}
\usepackage{inconsolata}
\usepackage[ngerman]{babel}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

\usepackage{microtype}

\usepackage{csquotes}
\MakeOuterQuote{"}

\usepackage{graphicx}
\usepackage{float}
\usepackage{bm}
\usepackage{amssymb}
\usepackage[hidelinks]{hyperref}
\usepackage[section]{placeins}

\usepackage{amsmath}

\usepackage{enumitem}  

%Change enummeration pattern from 1. to 1)
\renewcommand\labelenumi{\theenumi)}

%align lambda terms left, no spacing before or after environment
\newenvironment{nospaceflalign*}
 {\setlength{\abovedisplayskip}{0pt}\setlength{\belowdisplayskip}{0pt}%
  \csname flalign*\endcsname}
 {\csname endflalign*\endcsname\ignorespacesafterend}


\titlehead{\centering\includegraphics[width=6cm]{img/logo.pdf}}
\title{Testbericht}
\subtitle{Wavelength--$\bm{\lambda}$-IDE}
\author{Muhammet Guemues, Markus Himmel, Marc Huisinga,\\Philip Klemens, Julia Schmid, Jean-Pierre von der Heydt}

\begin{document}
\maketitle
\newpage
\tableofcontents
\newpage

\chapter{Testmethoden}

\section{Parser-Fuzzing}
Neben herkömmlichen JUnit-Tests und dem Parsen von zufällig generierten
$\lambda$-Termen kam zum Testen des Parsers ein Fuzzer zum Einsatz. Fuzzing ist
eine Testtechnik, bei der nach dem Modell eines genetischen Algorithmus
automatisch interessante Testfälle generiert werden, die neue interne Zustände
in der Applikation hervorrufen. Da der Fuzzer introspektiv mit der kompilierten
Applikation arbeitet, werden innerhalb von kurzer Zeit Testfälle gefunden, die
neue Ausnahmen oder Zustände hervorrufen.

Wavelength verwendet zum Fuzzen des Parsers die Java-Bibliothek
\textit{Javan Warty Pig\footnote{\url{https://github.com/cretz/javan-warty-pig}}},
welche die Instrumentationsfeatures der Java Virtual Machine nutzt, um Fuzzing
auf der Ebene des Java Bytecodes durchzuführen.

Durch das gezielte Suchen des Fuzzers nach neuen Programmzuständern ist der
Fuzzer in der Lage, innerhalb von Sekunden gültige $\lambda$-Terme und
Namenszuweisungen zu generieren, ohne vorher mit Informationen über die Struktur
von $\lambda$-Termen initialisiert zu werden. Ebenfalls konnte der Fuzzer innerhalb
von kurzer Zeit mehrere unerwartete Ausnahmen im Parser hervorrufen und syntaktisch
inkorrekte Testfälle generieren, die dennoch vom Parser akzeptiert wurden. Einige
dieser Bugs wären ohne die Verwendung eines Fuzzers mit hoher Wahrscheinlichkeit
unentdeckt geblieben.

Bei der Verwendung des Fuzzers wurden jedoch auch die Limitationen dieser Methodik
zum Testen deutlich. Der Fuzzer such spezifisch nach neuen internen Zuständen und
Ausführungspfaden. Fehlverhalten, welches nicht zu einer Verzweigung im
Programmfluss führt, ist für den Fuzzer somit nicht sichtbar. Im Fall des
Wavelength-Parsers wird dieser Umstand im Bezug auf Kommentare in der Eingabe
am deutlichsten -- im Parser existieren keine Branches, die abhängig vom
Vorhandensein eines Kommentars genommen werden. Das Resultat ist, dass durch
Fuzzen keine interessanten Testfälle zum Umgang mit Kommentaren gefunden werden.
Insbesondere gab es einen subtilen Fehler in der Kommentarentfernungsreoutine,
der auf den ersten Blick wie ein typischer durch einen Fuzzer indentifizierbarer
Fehlerfall aussieht, vom Fuzzer jedoch nicht entdeckt wurde. Daher stützen wir
uns zum Testen des Parsers nicht nur auf Fuzzing, sondern auch auf herkömmliche
manuell erstellte Komponententests.

\chapter{Testprotokolle}

\section{UI Tests}
%TODO Begründung warum keine Unittests



\subsection{Ausgabe}

\subsubsection{Unicode: Syntax Test}
Bei diesem Test ist lediglich die Syntax der Ausgabe relevant. Markierungen werden in späteren Tests abgedeckt.
Dieser Test wird mit folgenden Einstellungen durchgeführt: Reduktionsordnung 'Normal Order' und Ausgabegröße 'Full'. Es wurde immer die gesamte Ausgabe (sofern der Term terminiert) auf Syntaxfehler überprüft.

Es wurde mit folgenden Eingaben getestet:
\begin{nospaceflalign*}
	&\lambda x.x \\
	&(\lambda x.x) \ x \\
	&(\lambda x.x\ x\ x)\  (\lambda x.x\ x\ x) \\
	&(\lambda a.a) \ b \ (\lambda c.c) \ d \\
	&(\lambda a.a) \ b \ ((\lambda c.c) \ d) \\
	&(\lambda a. \lambda b.b)\ ((\lambda c.\ (\lambda d. d\ d)\ (\lambda e. e\ e))\ ((\lambda f. f) (\lambda g. g)))\ (\lambda h. \lambda i. i)&&
\end{nospaceflalign*}

\begin{nospaceflalign*}
	& \text{id} = \lambda x.x \\
	& \text{id} \ x &&
\end{nospaceflalign*}

\subsubsection{Unicode: Highlight Tests}

\paragraph{Redexe}
Nur Redexe im  Term werden als anklickbar markiert und ob nur diese lösen bei Klick eine Reaktion aus. Alle nicht markierten Teile des Terms sind nicht klickbar und lösen keine Reaktion aus.

Es wurde mit folgenden Termen getestet:
\begin{nospaceflalign*}
	&\lambda x.x \\
	&(\lambda x.x) x \\
	&(\lambda a.a) \ b \ (\lambda c.c) \ d \\
	&(\lambda a.a) \ b \ ((\lambda c.c) \ d) \\
	&(\lambda a. \lambda b.b)\ ((\lambda c.\ (\lambda d. d\ d)\ (\lambda e. e\ e))\ ((\lambda f. f) (\lambda g. g)))\ (\lambda h. \lambda i. i)&&
\end{nospaceflalign*}




\paragraph{Mouse-over}
Dieser Test testet das korrekte Verhalten bei Bewegen der Maus über Lambda-Terme. Nur bei hovern über einem Redex erscheint eine Markierung, diese erstreckt sich über den gesamten Redex. Weiterhin wird bei mouse-over die Markierung der Reduktionsordnung entfernt. 

Es wurde mit folgenden Eingaben getestet:
\begin{nospaceflalign*}
	&\lambda x.x \\
	&(\lambda x.x) x \\
	&(\lambda a.a) \ b \ (\lambda c.c) \ d \\
	&(\lambda a.a) \ b \ ((\lambda c.c) \ d) \\
	&(\lambda a. \lambda b.b)\ ((\lambda c.\ (\lambda d. d\ d)\ (\lambda e. e\ e))\ ((\lambda f. f) (\lambda g. g)))\ (\lambda h. \lambda i. i)&&
\end{nospaceflalign*}



\paragraph{Hintergrund}
Jeder neue Term wird in einer neuen Zeile ausgegeben und verschiedene Terme werden durch verschiedene Hintergrundfarben unterscheidbar gemacht.


\subsubsection{Unicode: Schritt vor}
Bei Schritt vor bleibt (per Button oder manuellem Klick) die Markierung des ausgewerteten Redex korrekt erhalten. Weiterhin sind Redexe im ursprünglichen Term nicht mehr anklickbar und auch bei mouse-over zeigen diese keine Reaktion. Der neu angezeigte Term verhält sich wie in den vorherigen Tests spezifiziert.

Es wurde mit folgenden Eingaben getestet:
\begin{nospaceflalign*}
	&\lambda x.x \\
	&(\lambda x.x) x \\
	&(\lambda a.a) \ b \ (\lambda c.c) \ d \\
	&(\lambda a.a) \ b \ ((\lambda c.c) \ d) \\
	&(\lambda a. \lambda b.b)\ ((\lambda c.\ (\lambda d. d\ d)\ (\lambda e. e\ e))\ ((\lambda f. f) (\lambda g. g)))\ (\lambda h. \lambda i. i)&&
\end{nospaceflalign*}

\subsubsection{Unicode: Schritt zurück}
Test1: 
Im Ausgabefenster wird ein einzelner Term angezeigt. Bei Schritt zurück wird dieser entfernt und das Ausgabefenster ist leer. 
Dieser Test funktioniert unabhängig von einem bestimmten Term.

Test2: 
Im Ausgabefenster wird mehr als ein Term angezeigt. Bei Schritt zurück wird der zuletzt angezeigte Term entfernt.
Beim nun letzten Term werden die Markierungen zurückgesetzt, das bedeutet, dass die Markierung des reduzierten Redex durch die Markierung der aktuell gewählten Reduktionsordnung ersetzt wird. Weiterhin sind nun alle Redexe wieder klickbar und mouse-over verhält sich wie oben getestet.

Es wurde mit folgenden Eingaben getestet:
\begin{nospaceflalign*}
	&\lambda x.x \\
	&(\lambda x.x) x \\
	&(\lambda a.a) \ b \ (\lambda c.c) \ d \\
	&(\lambda a.a) \ b \ ((\lambda c.c) \ d) \\
	&(\lambda a. \lambda b.b)\ ((\lambda c.\ (\lambda d. d\ d)\ (\lambda e. e\ e))\ ((\lambda f. f) (\lambda g. g)))\ (\lambda h. \lambda i. i)&&
\end{nospaceflalign*}



\subsubsection{Unicode: Reduktionsordnung}
Bei Änderung der Reduktionsordnung wird der zuletzt angezeigte Term entsprechend der neuen Reduktionsordnung neu markiert. 

Es wurde mit folgenden Eingaben getestet:
\begin{nospaceflalign*}
	&(\lambda a.a) \ b \ (\lambda c.c) \ d \\
	&(\lambda a.a) \ b \ ((\lambda c.c) \ d) \\
	&(\lambda a. \lambda b.b)\ ((\lambda c.\ (\lambda d. d\ d)\ (\lambda e. e\ e))\ ((\lambda f. f) (\lambda g. g)))\ (\lambda h. \lambda i. i)&&
\end{nospaceflalign*}


\subsubsection{Baum: Highlight Tests}
Nur Knoten von Redexen werden im Baum als solche farblich markiert.

Es wurde mit folgenden Eingaben getestet:
\begin{nospaceflalign*}
	&\lambda x.x \\
	&(\lambda x.x) x \\
	&(\lambda a.a) \ b \ (\lambda c.c) \ d \\
	&(\lambda a.a) \ b \ ((\lambda c.c) \ d) \\
	&(\lambda a. \lambda b.b)\ ((\lambda c.\ (\lambda d. d\ d)\ (\lambda e. e\ e))\ ((\lambda f. f) (\lambda g. g)))\ (\lambda h. \lambda i. i)&&
\end{nospaceflalign*}


\subsubsection{Baum: Änderung der Reduktionsordnung}
%TODO: siehe git issue
Bei Änderung der Reduktionsordnung wird der zuletzt angezeigte Baum entsprechend der neuen Reduktionsordnung neu gefärbt.

Es wurde mit folgenden Eingaben getestet:
\begin{nospaceflalign*}
	&(\lambda a.a) \ b \ ((\lambda c.c) \ d) \\
	&(\lambda a. \lambda b.b)\ ((\lambda c.\ (\lambda d. d\ d)\ (\lambda e. e\ e))\ ((\lambda f. f) (\lambda g. g)))\ (\lambda h. \lambda i. i)&&
\end{nospaceflalign*}


\subsubsection{Baum: Schritt vor und Schritt zurück}
Test1: Bei Schritt nach vorne bleibt die Knotenfärbung des letzten Baumes erhalten.

Test2: Bei Schritt nach vorne wird der neu anzuzeigende Baum unter den restlichen Bäumen in die Ausgabe eingefügt. Alle anderen Bäume bleiben unverändert.

Test3: Bei Schritt zurück wird der aktuelle Baum aus der Ausgabe entfernt und der nun letzte Baum ist entsprechend der gewählten Reduktionsordnung gefärbt.

\subsubsection{Formatwechsel}
Test1: Bei nicht leerem Ausgabefenster und einem Wechsel des Ausgabeformats wird nur der zuletzt angezeigte Term neu geladen entsprechend des neuen Formats. Die restlichen angezeigten Terme bleiben unverändert.

Test2: Bei Schritt vor (per Button, manuell oder durch Wiederaufnehmen der automatischen Ausführung) wird der neue Term entsprechend des neu gewählten Ausgabeformats angezeigt. 

Test3: Ein Formatwechsel hat keine Auswirkung auf bereits angezeigte Terme bei Schritt zurück. Diese werden in ihrem alten Ausgabeformat angezeigt (und ggf. neu markiert, siehe obige Tests).

Test4: Bei Formatwechsel bleibt die Hintergrundfärbung der Unicode-Terme konsistent. %TODO: Link zu git issue einfuegen


\chapter{Fehlerprotokoll}

\begin{itemize}[itemsep=3ex]

\newcommand{\issue}[3]{%
\item[]
\begin{itemize}[noitemsep]
\item[]\textbf{#1}
\item[\textbf{Grund:}]#2
\item[\textbf{Behebung:}]#3
\end{itemize}}


%issue 22
\issue{Wird die Lösung einer aktiven Übungsaufgaben angezeigt und eine neue Aufgabe geöffnet, wird das Lösungsfenster nicht geschlossen sondern die Lösung der neuen Aufgabe angezeigt. }
{Beim Öffnen einer neuen Übungsaufgabe wird der Status Lösungsfensters nicht zurückgesetzt.}
{Die LoadExercise Action setzt nun den Status des Lösungsfensters zurück bevor eine neue Übungsaufgabe angezeigt wird}

%issue 21
\issue{Wenn eine Rechnung in TreeOutput erfolgt und die Applikation anschließend serialisiert wird, werden die Teilschritte im UnicodeOutput angezeigt.}
{}
{}

%issue 20
\issue{Beim Öffnen einer neuen Redex-Übungsaufgabe kommt es manchmal zu einem Fehler.}
{Enthält der gesuchte Redex eine gebundene Variable deren bindende Abstraktion außerhalb des Redex liegt ist der Redex-Subterm kein valider Lambda-Term was zu einem Fehler bei der Ausgabe als String führt.}
{Vor der Ausgabe wird ein bereinigter Term für die Ausgabe erstellt. In diesem Term wurden alle gebundenen Variablen deren bindende Abstraktion nicht innerhalb des Redex liegt durch freie Variablen mit dem Namen der abstrahierten Variable ersetzt.}

% issue 19
\issue{}{}{}

% issue 18
\issue{}{}{}

% issue 17
\issue{Das Anhängen eines "-" an eine ansonsten korrekte Zeile der Eingabe führt nicht zu einem Fehler.}
{}
{}

% issue 16
\issue{}{}{}

% issue 15
\issue{Beginnt eine Eingabe mit eine Kommentar in der ersten Zeile, so wird sie nicht korrekt geparst sondern ein Fehler ausgegeben.}
{}
{}

% issue 14; TODO 
\issue{}{}{}

% issue 13; TODO
\issue{}{}{}

% issue 12; TODO
\issue{Veränderungen an von einer Übungsaufgabe vorgegebenen Term  werden beim Laden eines Serialisierungs-Links nicht wiederhergestellt, stattdessen wird der ursprünglich vorgegebene Term angezeigt.}
{Beim der Deserialisieren des Anwendungszustands wird zwar der Inhalt des Eingabefeldes wiederhergestellt, befand sich die Anwendung zum Zeitpunkt der Serialisierung jedoch im Übungsmodus, wird dieser daraufhin mit dem vorgegebenen Term überschrieben.}
{Der Inhalt des Eingabefeldes wird nun nach der Wiederherstellung der Übungsaufgabe wiederhergestellt und der vorgegebene Term gegebenenfalls überschrieben.}

% issue 11;TODO
\issue{}{}{}

% issue 10
\issue{Das Parsen einer Eingabe die nur aus Leerstellen besteht führt zu einem Fehler.}
{}
{}

% issue 9; Parser does not check for null
\issue{}{}{}

% issue 8; TODO
\issue{}{}{}

% issue 7
\issue{Im Uniode Ausgabeformat werden benannte Term nicht markiert auch wenn sie den als nächstes zu reduzierenden Redex enthalten.}
{}
{}

% issue 6; TODO
\issue{}{}{}

% issue 5; TODO
\issue{}{}{}

% issue 4
\issue{Enthält ein Lambda-Term  verschiedene Instanzen des gleichen vordefinierten Terms, so werden, sobald eine Instanz reduziert wird, auch alle anderen Instanzen reduziert.}
{}
{}

\end{itemize}


\end{document}
