\documentclass[parskip=full,11pt,openany]{scrreprt}

\usepackage[sfdefault,light]{roboto}
\usepackage{inconsolata}
\usepackage[ngerman]{babel}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

\usepackage{microtype}

\usepackage{csquotes}
\MakeOuterQuote{"}

\usepackage{graphicx}
\usepackage{float}
\usepackage{bm}
\usepackage{amssymb}
\usepackage[hidelinks]{hyperref}
\usepackage[section]{placeins}
\usepackage{booktabs}

\usepackage{amsmath}

\usepackage{enumitem} 

\usepackage{amssymb}% http://ctan.org/pkg/amssymb
\usepackage{pifont}% http://ctan.org/pkg/pifont
\newcommand{\cmark}{\ding{51}}%
\newcommand{\xmark}{\ding{55}}% 

\usepackage[]{hyperref}
\usepackage{makecell}


%Change enummeration pattern from 1. to 1)
\renewcommand\labelenumi{\theenumi)}

%align lambda terms left, no spacing before or after environment
\newenvironment{nospaceflalign*}
 {\setlength{\abovedisplayskip}{0pt}\setlength{\belowdisplayskip}{0pt}%
  \csname flalign*\endcsname}
 {\csname endflalign*\endcsname\ignorespacesafterend}


\titlehead{\centering\includegraphics[width=6cm]{img/logo.pdf}}
\title{Testbericht}
\subtitle{Wavelength--$\bm{\lambda}$-IDE}
\author{Muhammet Guemues, Markus Himmel, Marc Huisinga,\\Philip Klemens, Julia Schmid, Jean-Pierre von der Heydt}

\begin{document}
\maketitle
\newpage
\tableofcontents
\newpage

\chapter{Überblick}

\section{Einleitung}

%TODO kurze Einleitung. Verwendete Tools, Daten (Coverage, #Testcases)

\section{Änderungen in der Applikation}
\subsection{Optionen}
Im Pflichtenheft wurde spezifiziert, dass bei einer laufenden Auswertung weder Output-Format noch Output-Size
oder Reduktionsordnung geändert werden können. Im Schritt-für-Schritt Modus sollten weder Output-Format noch
Output-Size geändert werden können. 

Mittlerweile kann jede einzelne Option sowohl während einer laufenden Auswertung als auch im Schritt-für-Schritt Modus
geändert werden. Die Änderungen gelten nur für den aktuellen und alle nachfolgenden Terme.

\subsection{Workflow}\label{changeWorkflow}
Um die Auswertung von $\lambda$-Termen flüssiger zu gestalten wurden die Knöpfe überarbeitet:

Es gibt nun einen run-Button, der eine neue Komplettauswertung startet und einen clear-Button, der das Output-Fenster leert.
Während der Auswertung können der step-forward- und der step-backward-Button gedrückt werden, was die Auswertung pausiert. 
Die Auswertung kann auch über den pause-Button pausiert werden.
Eine pausierte Auswertung kann den über den unpause-Button fortgesetzt werden.
Der step-forward-Button kann auch für den ersten Auswertungsschritt einer Eingabe benutzt werden und der step-backward-Button
kann den ersten Auswertungsschritt rückgängig machen.

\subsection{Benutzbarkeit}
Um die Nutzung der Anwendung insgesamt intuitiver zu gestalten ergeben sich eine Reihe kleiner Änderungen:

\begin{itemize}
\item Es gibt nun Tooltips zu jeder Schaltfläche, die die Funktion erklären.
\item Der clear-Button kann mit "CTRL und BACKSPACE" ausgelöst werden und der run-Button mit "CTRL und ENTER".
\item Die Popups beim Wechsel zwischen dem normalen- und dem Übungsmodus können mit "ENTER" akzeptiert und mit
"ESCAPE" abgebrochen werden.
\item Es gibt nun einen Spinner, der anzeigt, dass eine gerade eine Auswertung läuft.
\item Es wird nun angezeigt, wie viele Reduktionsschritte für eine Auswertung benötigt wurden.
\item Sind Bibliotheken ausgewählt, so kann durch "CTRL und SPACE" eine Liste von Vorschlägen von Termen aus den 
Bibliotheken angezeigt werden.
\end{itemize}

\subsection{Randomisierte Übungsaufgaben}
Zu jeder Auswertungsstrategie gibt es eine Übungsaufgabe, die einen zufällig generierten $\lambda$-Term erzeugt
und nach dem nächsten auszuwertenden Redex fragt.

\subsection{Serialisierung}
Nach der Implementierungsphase wurde der Zustand der Anwendung in regelmäßigen Abständen serialisiert und 
ein entsprechender Link generiert, der vom Browser übernommen wurde.
Da die Verwendung von URL-Parametern ein Neuladen der Seite erzwingen würde, wurde vom verantwortlichen 
Entwickler die History von GWT zweckentfremdet.
Dadurch konnten im Browser kurioserweise die Vorwärts- und die Rückwarts-Schaltfläche benutzt werden, wobei
der aktuelle History-Token durch den nächsten respektive letzten ersetzt wurde.
Darüber hinaus stellt die ständige Serialisierung hinsichtlich des Speicherverbrauchs ein auf Dauer unhandliches
Problem dar.

Aus diesen Gründen wurde die ständige Serialisierung entfernt. Sie erfolgt nun nur noch on-demand beim Klicken
des Share-Buttons. Intern wurden die History-Tokens durch die sinnvolleren URL-Parameter ersetzt.

\subsection{Maximale Größe und Tiefe für $\lambda$-Terme}
Die für das $\lambda$-Kalkül typische Repräsentation natürlicher Zahlen ist die
Church-Codierung, welche auch bei der in Wavelength beinhalteten Bibliothek für
natürliche Zahlen zum Einsatz kommt. Die Tiefe dieser $\lambda$-Terme ist linear
in der Größe der repräsentierten Zahl. Da Wavelength für Operationen auf
$\lambda$-Termen das Visitor-Pattern verwendet, ist die Tiefe der
verschachtelten Aufrufe proportional zur Tiefe des $\lambda$-Terms. Beim Umgang mit großen
Zahlen treten somit notwendigerweise Überläufe des Aufrufstapels auf.

Der duale pathologische Fall ist der, in dem der Baum, den der Term bildet,
ein vollständiger binärer Baum aus Applikationen ist. Dieser Term hat nur eine
geringe Tiefe, aber sehr viele Knoten. Beim Versuch, einen solchen Term zu
parsen, wird sehr viel Speicher allokiert, was zum Crash der Applikation im
Browser führt.

Um diese Fehlerfälle systematisch behandeln zu können, wurden eine applikationsweite
Maximaltiefe und Maximalgröße für $\lambda$-Terme eingeführt. Werden diese beim Parsen oder Reduzieren
eines $\lambda$-Terms überschritten, wird eine Ausnahme generiert, sodass dem
Nutzer eine Fehlermeldung angezeigt werden kann.

\subsection{Veränderung des Sytax für Eingaben}
Die Syntax für die Eingabe von $\lambda$-Termen hat sich an einigen Stellen verändert. 
Kommentare werden durch "-$\,$-" anstatt "$\backslash\backslash$" markiert\label{changeComment} 
und die Bezeichnung für einige Bibliotheksfunktionen wurde geändert\label{changeBib}. 
Die ursprüngliche Spezifikation erlaubte keine doppelte Namensbindung. 
In der finalen Version der Applikation überschatten sich die Namensbindungen\label{changeBinding}.

\section{Abdeckung der Tests im Pflichtenheft}

Die folgende Tabelle greift die im Pflichtenheft definierten Test auf und gibt an,
welche davon automatisch getestet werden. 
Es ist zu beachten, dass mit Ausnahme derjenigen Testszenarien die in Entwurfs- oder
Implementierungsphase verworfen wurden, kein Test bei manueller Durchführung fehlschlägt.\\
Einige Testszenarien wurden and die aktuelle Spezifikation der Applikation angepasst. 
Lediglich die Test zu der Baum-Ausgabe konnten nicht automatisch durchgeführt werden.

\begin{table}[h]
	\centering
	\begin{tabular}{@{}ll|c|r@{}}
		\toprule
		&\textbf{Test Nr.} & \makecell{\textbf{Automatisch}\\\textbf{getestet}} &\textbf{Anmerkung} \\ 
		\midrule
		\multicolumn{3}{l|}{\small \textsc{\textbf{T1} Komplettauswertung}} \\ 
		&T1.1 & \cmark & \\
		&T1.2 & (\cmark) & Das Verhalten des Editors wurde nicht getestet \\
		&T1.3 & \cmark & \\ 
		\multicolumn{3}{l|}{\small \textsc{\textbf{T2} Schritt-für-Schritt-Modus}}\\ 
		&T2.1 & \cmark & An die neue Benutzeroberfläche angepasst vgl. \ref{changeWorkflow} \\
		&T2.2 - T2.9 & \cmark & \\
		\multicolumn{3}{l|}{\small \textsc{\textbf{T3} Erstellen von Permalinks}}\\ 	
		&T3.1 - T3.4 & \cmark & \\
		\multicolumn{3}{l|}{\small \textsc{\textbf{T4} Übungsmodus}}\\ 
		&T4.1 & \cmark & \\
		&T4.2 - T4.3 & (\xmark) & Feature wurde in der Entwurfsphase verworfen \\
		&T4.4 & \cmark & \\
		&T4.5 & (\xmark) & Feature wurde in der Entwurfsphase verworfen \\
		&T4.6 & \cmark & \\
		&T4.7 & (\xmark) & Es existiert keine Übungsaufgabe der geforderten Form \\
		&T4.8 - T4.9 & \cmark & \\
		\multicolumn{3}{l|}{\small \textsc{\textbf{T5} Ausgabeformat}}\\ 
		&T5.1 & \cmark & \\
		&T5.2 & (\xmark) & Feature wurde in der Implementierungsphase verworfen\\
		&T5.3 & \xmark & Wurde nur manuell getestet \\ %TODO Anmerkung in einem Text
		\multicolumn{2}{l|}{\small \textsc{\textbf{T6} Export}} & &\\ 
		&T6.1 - T6.3 & \cmark & \\
		\multicolumn{3}{l|}{\small \textsc{\textbf{T7} Namensbindung}}\\ 
		&T7.1 - T7.2 & \cmark & \\
		&T7.3 & \cmark & \makecell[r]{Spezifikation für doppelte Namensbindung\\wurde geändert vgl. \ref{changeBinding}} \\
		\multicolumn{4}{l}{\small \textsc{\textbf{T8} Auswahl des Ausgabeumfangs}}\\ 
		&T8.1 - T8.2 & \cmark & \\
		&T8.3 & \xmark & Wurde nur manuell getestet \\ %TODO Anmerkung in einem Text
		\multicolumn{4}{l}{\small \textsc{\textbf{T9} Wechsel des Auswertungsmodus}}\\ 
		&T9.1 - T9.2 & \cmark & \\
		&T9.3 & \cmark & An die neue Benutzeroberfläche angepasst  vgl. \ref{changeWorkflow}\\
		\multicolumn{3}{l|}{\small \textsc{\textbf{T10} Standardbibliothek}}\\ 
		&T10.1 - T10.7 & \cmark & \\
		&T10.8 - T10.9 & \cmark & \makecell[r]{Bibliotheksfunktionen umbenannt\\und leicht angepasst vlg. \ref{changeBib}} \\
		\multicolumn{3}{l|}{\small \textsc{\textbf{T11} Fehlerdiagnostik}}\\ 
		&T11.1 - T11.3 & \cmark & \\
		&T11.4 & \cmark & Syntax für Kommentare wurde geändert vgl. \ref{changeComment} \\
		&T11.5 & \cmark & \\
		\bottomrule
	\end{tabular}
	\caption{Übersicht zur Abdeckung der Test aus dem Pflichtenheft}
\end{table}


\chapter{Testmethoden}
%TODO Coverage, wie viel? warum nur im Model?
%TODO Was war möglich? was nicht?

\section{Komponententests}
Für das gesamte Model und große Teile der Benutzeroberläche, wo dies realistisch
machbar ist, wurden \textsc{JUnit}-Tests geschrieben, welche auf der Java Virtual
Machine ausgeführt werden. Die hiervon betroffenen Pakete werden durch etwa 300
Testfälle getestet und es wird eine Testabdeckung von über 95\% erzielt. Hierbei
hadelt es sich bei vielen Tests um spezifisch entwickelte Testfälle; in einigen
anderen Testfällen wurden Fehler festgehalten, die auf andere Weise gefunden
wurden, um automatisiert sicherzustellen, dass dieser Fehler nicht erneut
auftritt. Eine weitere Kategorie von Komponententests bilden solche, die zufällig Strukturen
(insbesondere $\lambda$-Terme) generieren und sicherstellen, dass Paare von
Operationen wie \enquote{Ausgeben} und \enquote{Parsen} sowie \enquote{Serialisieren}
und \enquote{Deserialisiseren} invers zueinander sind.

\section{Selenium}
%TODO text

\section{Parser-Fuzzing}
Neben herkömmlichen JUnit-Tests und dem Parsen von zufällig generierten
$\lambda$-Termen kam zum Testen des Parsers ein Fuzzer zum Einsatz. Fuzzing ist
eine Testtechnik, bei der nach dem Modell eines genetischen Algorithmus
automatisch interessante Testfälle generiert werden, die neue interne Zustände
in der Applikation hervorrufen. Da der Fuzzer introspektiv mit der kompilierten
Applikation arbeitet, werden innerhalb von kurzer Zeit Testfälle gefunden, die
neue Ausnahmen oder Zustände hervorrufen.

Wavelength verwendet zum Fuzzen des Parsers die Java-Bibliothek
\textsc{Javan Warty Pig\footnote{\url{https://github.com/cretz/javan-warty-pig}}},
welche die Instrumentationsfeatures der Java Virtual Machine nutzt, um Fuzzing
auf der Ebene des Java Bytecodes durchzuführen.

Durch das gezielte Suchen des Fuzzers nach neuen Programmzuständern ist der
Fuzzer in der Lage, innerhalb von Sekunden gültige $\lambda$-Terme und
Namenszuweisungen zu generieren, ohne vorher mit Informationen über die Struktur
von $\lambda$-Termen initialisiert zu werden. Ebenfalls konnte der Fuzzer innerhalb
von kurzer Zeit mehrere unerwartete Ausnahmen im Parser hervorrufen und syntaktisch
inkorrekte Testfälle generieren, die dennoch vom Parser akzeptiert wurden. Einige
dieser Bugs wären ohne die Verwendung eines Fuzzers mit hoher Wahrscheinlichkeit
unentdeckt geblieben.

Bei der Verwendung des Fuzzers wurden jedoch auch die Limitationen dieser Methodik
zum Testen deutlich. Der Fuzzer sucht spezifisch nach neuen internen Zuständen und
Ausführungspfaden. Fehlverhalten, welches nicht zu einer Verzweigung im
Programmfluss führt, ist für den Fuzzer somit nicht sichtbar. Im Fall des
Wavelength-Parsers wird dieser Umstand im Bezug auf Kommentare in der Eingabe
am deutlichsten -- im Parser existieren keine Branches, die abhängig vom
Vorhandensein eines Kommentars genommen werden. Das Resultat ist, dass durch
Fuzzen keine interessanten Testfälle zum Umgang mit Kommentaren gefunden werden.
Insbesondere gab es einen subtilen Fehler in der Kommentarentfernungsreoutine,
der auf den ersten Blick wie ein typischer durch einen Fuzzer indentifizierbarer
Fehlerfall aussieht, vom Fuzzer jedoch nicht entdeckt wurde. Daher stützen wir
uns zum Testen des Parsers nicht nur auf Fuzzing, sondern auch auf herkömmliche
manuell erstellte Komponententests.

Neben dem Beheben der durch Fuzzing identifizierten Fehler wurden die entsprechenden
Testfälle in Unittests festgehalten, um Regressionen entgegenzuwirken.

\chapter{Testprotokolle}

\section{Ausgabe Highlighttests}

Die nachfolgenden Tests wurden mit folgenden Eingaben getestet:

\begin{nospaceflalign*}
	&\lambda x.\, x \\
	&(\lambda x.\, x)\: x \\
	&(\lambda x.\, x\: x\: x)\: (\lambda x.\, x\: x\: x) \\
	&(\lambda a.\, a)\: b\: (\lambda c.\, c)\: d \\
	&(\lambda a.\, a)\: b \: ((\lambda c.\, c)\: d) \\
	&(\lambda a.\, \lambda b.\, b)\: ((\lambda c.\, (\lambda d.\, d\: d)\: (\lambda e.\, e\: e))\: ((\lambda f.\, f)\: (\lambda g.\, g)))\: (\lambda h.\, \lambda i.\, i)&&
\end{nospaceflalign*}

\begin{nospaceflalign*}
	& \text{id} = \lambda x.\, x \\
	& \text{id}\ x &&
\end{nospaceflalign*}

\begin{nospaceflalign*}
	& \text{curry} = \lambda f.\, \lambda a.\, \lambda b.\, f \, (\text{pair}\, a\: b) \\
	&(\text{curry}\, (\lambda p.\, (\text{first}\, p)\ (\text{second}\, p)))\, x\: x &&
\end{nospaceflalign*}

\begin{nospaceflalign*}
	&\text{plus} = \text{plus} \: 1000 \\
	&\text{plus} = \text{plus} \\
	&\text{plus} \: 1 &&
\end{nospaceflalign*}

%TODO: mehr Terme

\subsection{Redexe}
Nur Redexe im  Term werden als anklickbar markiert und nur diese lösen bei Klick eine Reaktion aus. Alle nicht markierten Teile des Terms sind nicht klickbar und lösen keine Reaktion aus.


\subsection{Mouse-over}
Nur bei hovern über einem Redex erscheint eine Markierung, diese erstreckt sich über den gesamten Redex. Weiterhin wird bei mouse-over die Markierung der Reduktionsordnung entfernt. 


\subsection{Hintergrund}
Jeder neue Term wird in einer neuen Zeile ausgegeben und verschiedene Terme werden durch verschiedene Hintergrundfarben unterscheidbar gemacht.


\subsection{Unicode: Schritt vor}
Bei Schritt vor bleibt (per Button oder manuellem Klick) die Markierung des ausgewerteten Redex korrekt erhalten. Weiterhin sind Redexe im ursprünglichen Term nicht mehr anklickbar und auch bei mouse-over zeigen diese keine Reaktion. Der neu angezeigte Term verhält sich wie in den vorherigen Tests spezifiziert.

\subsection{Unicode: Schritt zurück}
Test1: 
Im Ausgabefenster wird ein einzelner Term angezeigt. Bei Schritt zurück wird dieser entfernt und das Ausgabefenster ist leer. 
Dieser Test funktioniert unabhängig von einem bestimmten Term.

Test2: 
Im Ausgabefenster wird mehr als ein Term angezeigt. Bei Schritt zurück wird der zuletzt angezeigte Term entfernt.
Beim nun letzten Term werden die Markierungen zurückgesetzt, das bedeutet, dass die Markierung des reduzierten Redex durch die Markierung der aktuell gewählten Reduktionsordnung ersetzt wird. Weiterhin sind nun alle Redexe wieder klickbar und mouse-over verhält sich wie oben getestet.

\subsection{Unicode: Reduktionsordnung}
Bei Änderung der Reduktionsordnung wird der zuletzt angezeigte Term entsprechend der neuen Reduktionsordnung neu markiert. 

\subsection{Baum: Knotenmarkierung}
Nur Knoten von Redexen werden im Baum als solche farblich markiert. Dabei ist der Knoten mit dem Redex, welcher als nächstes ausgewertet wird anders markiert als die übrigen Redexe.

\subsection{Baum: Änderung der Reduktionsordnung}
%TODO: siehe git issue
Bei Änderung der Reduktionsordnung wird der zuletzt angezeigte Baum entsprechend der neuen Reduktionsordnung neu gefärbt. Die restlichen Bäume behalten ihre bisherige Färbung bei.

\subsection{Baum: Schritt vor und Schritt zurück}
Test1: Bei Schritt nach vorne bleibt die Knotenfärbung des aktuellen Baumes erhalten.

Test2: Bei Schritt nach vorne wird der neu anzuzeigende Baum unter den restlichen Bäumen in die Ausgabe eingefügt. Alle anderen Bäume bleiben unverändert.

Test3: Bei Schritt zurück wird der aktuelle Baum aus der Ausgabe entfernt und der nun letzte Baum ist entsprechend der gewählten Reduktionsordnung neu gefärbt.

\subsection{Formatwechsel}
Test1: Bei nicht leerem Ausgabefenster und einem Wechsel des Ausgabeformats wird nur der zuletzt angezeigte Term neu geladen entsprechend des neuen Formats. Die restlichen angezeigten Terme bleiben unverändert.

Test2: Bei Schritt vor (per Button, manuell oder durch Wiederaufnehmen der automatischen Ausführung) wird der neue Term entsprechend des neu gewählten Ausgabeformats angezeigt. 

Test3: Ein Formatwechsel hat keine Auswirkung auf bereits angezeigte Terme bei Schritt zurück. Diese werden in ihrem alten Ausgabeformat angezeigt (und ggf. neu markiert, siehe obige Tests).

Test4: Bei Formatwechsel bleibt die Hintergrundfärbung der Unicode-Terme konsistent. %TODO: Link zu git issue einfuegen



\chapter{Fehlerprotokoll}
%TODO Fehler Sortieren und Kategorisieren

\begin{itemize}[itemsep=3ex]

\newcommand{\issue}[3]{%
\item[]
\begin{itemize}[noitemsep]
\item[]\textbf{#1}
\item[\textbf{Grund:}]#2
\item[\textbf{Behebung:}]#3
\end{itemize}}

%issue 44
\issue{Wird die Position eines Fehlers in der Eingabe ausgegeben, ist die rechte Grenze des Positionsintervalls genau um Eins größer als erwartet.}
{arg2}
{arg3}

%issue 43
\issue{In den Exportformaten Plaintext, Unicode ud LaTeX wird ein Reduktionspfeil vor dem Ausgangsterm in der ersten Zeile ausgegeben.}
{arg2}{arg3}

%issue 41
\issue{arg1}
{arg2}
{arg3}

%issue 34
\issue{arg1}
{arg2}
{arg3}

%issue 33
\issue{arg1}{arg2}{arg3}

%issue 31
\issue{arg1}{arg2}{arg3}

%issue 27
\issue{Wird die Lösung einer aktiven Übungsaufgabe angezeigt und eine neue Aufgabe geöffnet, wird das Lösungsfenster nicht geschlossen, sondern die Lösung der neuen Aufgabe angezeigt. }
{Beim Öffnen einer neuen Übungsaufgabe wird der Status des Lösungsfensters nicht zurückgesetzt.}
{Die LoadExercise Action setzt nun den Status des Lösungsfensters zurück, bevor eine neue Übungsaufgabe angezeigt wird}

%issue 26
\issue{Wenn eine Rechnung in TreeOutput erfolgt und die Applikation anschließend serialisiert wird, werden die Teilschritte im UnicodeOutput angezeigt.}
{}
{}

%issue 23
\issue{Beim Öffnen einer neuen Redex-Übungsaufgabe kommt es manchmal zu einem Fehler.}
{Enthält der gesuchte Redex eine gebundene Variable, deren bindende Abstraktion außerhalb des Redex liegt, ist der Redex-Subterm kein valider Lambda-Term, was zu einem Fehler bei der Ausgabe als String führt.}
{Vor der Ausgabe wird ein bereinigter Term für die Ausgabe erstellt. In diesem Term wurden alle gebundenen Variablen deren bindende Abstraktion nicht innerhalb des Redex liegt durch freie Variablen mit dem Namen der abstrahierten Variable ersetzt.}

% issue 19
\issue{}{}{}

% issue 18
\issue{}{}{}

% issue 16
\issue{Namenszuweisungen schattieren einander nicht, sondern es wird immer die erste Zuweisung verwendet.}
{Die zugewiesenen Namen wurden in der falschen Reiehenfolge zur Auflösung durchsucht.}
{Die Durchsuchungsreihenfolge wurde umgekehrt.}

% issue 14; TODO 
\issue{Die farbliche Abgrenzung der Terme im Unicode-Ausgabeformat verhält sich nicht korrekt bei mehrmaligem Formatwechsel. Der Hintergrund zweier aufeinanderfolgender Terme wird bei Wechsel, Schritt vor und Schritt zurück gleich gefärbt.}{Alle Interaktion des Ausgabefensters, unabhängig von der Wahl des Formats, haben Einfluss auf die Hintergrundfarbe.}{Die Hintergrundfarbe wird nur verändert, wenn Terme im Unicodeformat hinzugefügt, entfernt oder manipuliert werden.}

% issue 13; TODO
\issue{Bei Wechseln des Ausgabeformats sind verschiedene Formate in der Ausgabe gemischt angezeigt. Schritt zurück resultiert in Konvertierung des zuletzt angezeigten Terms in das neue Ausgabeformat.}{Formatwechsel während einer Ausgabe wurden nicht deaktiviert. Dies ist ein Resultat des neuen Workflows. %TODO: hier kann Marc evtl mehr zu schreiben
}{Formatwechsel ist nun möglich, auch während einer laufenden Auswertung. Dabei wird nur der zuletzt angezeigte und alle folgenden Terme entsprechend des neuen Ausgabeformats geladen. Die bisher angezeigten Terme bleiben in ihrem ursprünglichen Format erhalten und werden bei Schritt zurück auch entsprechend dieses Formats behandelt.}

% issue 12; TODO
\issue{Veränderungen an von einer Übungsaufgabe vorgegebenen Term  werden beim Laden eines Serialisierungs-Links nicht wiederhergestellt, stattdessen wird der ursprünglich vorgegebene Term angezeigt.}
{Beim der Deserialisieren des Anwendungszustands wird zwar der Inhalt des Eingabefeldes wiederhergestellt, befand sich die Anwendung zum Zeitpunkt der Serialisierung jedoch im Übungsmodus, wird dieser daraufhin mit dem vorgegebenen Term überschrieben.}
{Der Inhalt des Eingabefeldes wird nun nach der Wiederherstellung der Übungsaufgabe wiederhergestellt und der vorgegebene Term gegebenenfalls überschrieben.}

% issue 11;TODO
\issue{Bestimmte syntaktisch inkorrekte Namenszuweisungen führen zu Ausnahmen oder werden akzeptiert.}
{Der Parser hat Zeilen, die das Symbol \enquote{\texttt{=}} mehrfach enthalten, nicht als Syntaxfehler identifiziert und
alles ab dem zweiten \enquote{\texttt{=}}-Symbol verworfen.}
{Namenszuweisungen, die nicht exakt aus einem Namen, einem \enquote{\texttt{=}}-Symbol und einem gültigen
$\lambda$-Term bestehen, werden abgelehnt.}

% issue 8; TODO
\issue{}{}{}


% issue 6; TODO
\issue{}{}{}

% issue 5; TODO
\issue{}{}{}

% issue 4
\issue{Enthält ein $\lambda$-Term verschiedene Instanzen des gleichen vordefinierten Terms, so werden, sobald eine Instanz reduziert wird, auch alle anderen Instanzen reduziert.}
{Der Mechanismus zur Auflösung gebundener Namen hat für den gleichen Namen stets das gleiche Objekt
herausgegeben, sodass die Objektstruktur, die den geparsten Term repräsentiert, kein echter Baum war.}
{Benannte Terme werden vor dem Einbauen dupliziert.}

\end{itemize}


\end{document}
